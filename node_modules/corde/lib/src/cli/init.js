"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.init = void 0;

const tslib_1 = require("tslib");

const chalk_1 = tslib_1.__importDefault(require("chalk"));

const fs_1 = tslib_1.__importDefault(require("fs"));

const path_1 = tslib_1.__importDefault(require("path"));

const errors_1 = require("../errors");

const config = {
  botPrefix: "",
  botTestId: "",
  channelId: "",
  cordeBotToken: "",
  guildId: "",
  testMatches: [""],
  botToken: "",
  timeOut: 5000,
};
const configString = JSON.stringify(config);
const jsonFile = {
  $schema: "./node_modules/corde/schema/corde.schema.json",
  ...config,
};
const jsFile = `
    /** @type {import('corde/lib/src/types').IConfigOptions} */
    module.exports = ${configString}
`;
const tsFile = jsFile;

function init(fileType = "json") {
  let fileContent = "";

  if (!fileType) {
    fileType = "json";
  }

  if (fileType === "json") {
    fileContent = JSON.stringify(jsonFile);
  } else if (fileType === "js") {
    fileContent = jsFile;
  } else if (fileType === "ts") {
    fileContent = tsFile;
  } else {
    console.log(
      ` - ${chalk_1.default.bold(fileType)} is not a valid type. Use '${chalk_1.default.bold(
        "init --help",
      )}' to check valid types`,
    );
  }

  try {
    const fileName = `corde.config.${fileType}`;
    const filePath = path_1.default.resolve(process.cwd(), fileName);
    fileContent = formatFile(fileContent, fileType);
    fs_1.default.writeFileSync(filePath, fileContent);
    console.log(
      `- ${chalk_1.default.green("Successfully")} generated corde config in ${chalk_1.default.bold(
        filePath,
      )}`,
    );
  } catch (error) {
    throw new errors_1.FileError(
      " - Fail in config file creation. Check if you have permission to create files in this directory.",
    );
  }
}

exports.init = init;

function formatFile(file, type) {
  let formater = "json";

  if (type === "js" || type === "ts") {
    formater = "object";
  }

  return format(file, {
    formater,
    size: 2,
    type: "space",
  });
}

let p = [];
const indentConfig = {
  tab: {
    char: "\t",
    size: 1,
  },
  space: {
    char: " ",
    size: 4,
  },
};
const configDefault = {
  type: "tab",
  size: 2,
  formater: "json",
};

function push(m) {
  return "\\" + p.push(m) + "\\";
}

function pop(_, i) {
  return p[i - 1];
}

function tabs(count, indentType) {
  return new Array(count + 1).join(indentType);
}

function format(json, config) {
  config = config || configDefault;
  const indent = indentConfig[config.type];
  const indentType = new Array((config.size || indent.size) + 1).join(indent.char);
  let stringObjt = typeof json === "string" ? json : JSON.stringify(json);

  if (config.formater === "object") {
    stringObjt = stringObjt.replace(/"([^"]+)":/g, "$1:");
  }

  return formatStringObject(stringObjt, indentType);
}

function formatStringObject(json, indentType) {
  p = [];
  let out = "";
  let indent = 0;
  json = json
    .replace(/\\./g, push)
    .replace(/(".*?"|'.*?')/g, push)
    .replace(/\s+/, "");

  for (let i = 0; i < json.length; i++) {
    const c = json.charAt(i);

    switch (c) {
      case "{":
        out += c + "\n" + tabs(++indent, indentType);
        break;

      case "}":
        out += "\n" + tabs(--indent, indentType) + c;
        break;

      case ",":
        out += ",\n" + tabs(indent, indentType);
        break;

      case ":":
        out += ": ";
        break;

      default:
        out += c;
        break;
    }
  }

  out = out
    .replace(/\[[\d,\s]+?\]/g, (m) => {
      return m.replace(/\s/g, "");
    })
    .replace(/\\(\d+)\\/g, pop)
    .replace(/\\(\d+)\\/g, pop);
  return out;
}
