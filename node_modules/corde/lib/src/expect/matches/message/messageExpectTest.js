"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true,
});
exports.MessageExpectTest = void 0;

const tslib_1 = require("tslib");

const assert_1 = tslib_1.__importDefault(require("assert"));

const discord_js_1 = require("discord.js");

const utils_1 = require("../../../utils");

const expectTest_1 = require("../expectTest");

class MessageExpectTest extends expectTest_1.ExpectTest {
  validateExpect(expect) {
    if (!utils_1.isPrimitiveValue(expect) && utils_1.typeOf(expect) !== "object") {
      return this.createReport(
        "expected: expect value to be a primitive value (string, boolean, number) or an IMessageEmbed\n",
        `received: ${utils_1.typeOf(expect)}`,
      );
    }

    return null;
  }

  createReportForExpectAndResponse(expect, returnedMessage) {
    this.hasPassed = this.messagesMatches(returnedMessage, expect);
    this.invertHasPassedIfIsNot();

    if (this.hasPassed) {
      return this.createPassTest();
    }

    if (this.isNot) {
      return this.createReport(
        "expected: message from bot be different from expectation\n",
        "received: both returned and expectation are equal",
      );
    }

    let embedExpect;

    if (utils_1.typeOf(expect) === "object") {
      embedExpect = this.getMessageByType(expect, "embed");
    }

    let embedReturned;

    if (returnedMessage.embeds[0]) {
      embedReturned = this.getMessageByType(returnedMessage, "embed");
    }

    if (embedExpect && embedReturned) {
      return this.createReport(utils_1.diff(embedReturned, embedExpect));
    }

    if (embedExpect && !embedReturned) {
      return this.createReport(
        `expected: ${utils_1.formatObject(embedExpect)}\n`,
        `received: '${returnedMessage.content}'`,
      );
    }

    if (!embedExpect && embedReturned) {
      return this.createReport(
        `expected: '${expect}'\n`,
        `received: ${utils_1.formatObject(embedReturned)}`,
      );
    }

    return this.createReport(`expected: '${expect}'\n`, `received: '${returnedMessage.content}'`);
  }

  messagesMatches(returnedMessage, expectation) {
    let msg = "";

    if (utils_1.isPrimitiveValue(expectation)) {
      const formattedMsg = this.getMessageByType(returnedMessage, "text");
      msg = formattedMsg.content;
      return msg == expectation;
    }

    const jsonMessage = this.getMessageByType(returnedMessage, "embed");
    msg = JSON.stringify(jsonMessage);
    let result = true;

    try {
      assert_1.default.deepStrictEqual(expectation.toJSON(), jsonMessage);
    } catch (error) {
      result = false;
    }

    return result;
  }

  getMessageByType(answer, type) {
    if (type === "embed") {
      const embed = answer instanceof discord_js_1.Message ? answer.embeds[0] : answer;

      if (!embed) {
        return null;
      }

      const tempObject = embed.toJSON();

      if (tempObject.image) {
        tempObject.image = utils_1.pick(tempObject.image, "url");
      }

      if (tempObject.thumbnail) {
        tempObject.thumbnail = utils_1.pick(tempObject.thumbnail, "url");
      }

      return tempObject;
    } else {
      return answer;
    }
  }

  humanizeMessageIdentifierObject(msgIdentifier) {
    if (!msgIdentifier) {
      return "";
    }

    if (msgIdentifier !== null && msgIdentifier !== void 0 && msgIdentifier.id) {
      return `message of id ${msgIdentifier.id}`;
    }

    if (msgIdentifier.content) {
      return `message of content "${msgIdentifier.content}"`;
    }

    if (msgIdentifier.oldContent) {
      return `message of content "${msgIdentifier.oldContent}"`;
    }

    return "";
  }

  embedMessageLikeToMessageEmbed(embedLike) {
    const embed = new discord_js_1.MessageEmbed();

    if (!embedLike || utils_1.typeOf(embedLike) !== "object") {
      return embed;
    }

    if (embedLike.author) {
      if (typeof embedLike.author === "string") {
        embed.setAuthor(embedLike.author);
      } else {
        embed.setAuthor(embedLike.author.name, embedLike.author.iconURL, embedLike.author.url);
      }
    }

    if (embedLike.color) {
      embed.setColor(embedLike.color);
    }

    if (embedLike.description) {
      embed.setDescription(embedLike.description);
    }

    if (embedLike.fields) {
      embed.addFields(...embedLike.fields);
    }

    if (embedLike.files) {
      embed.attachFiles(embedLike.files);
    }

    if (embedLike.footer) {
      if (typeof embedLike.footer === "string") {
        embed.setFooter(embedLike.footer);
      } else {
        embed.setFooter(embedLike.footer.text, embedLike.footer.iconURL);
      }
    }

    if (embedLike.image) {
      if (typeof embedLike.image === "string") {
        embed.setImage(embedLike.image);
      } else {
        embed.setImage(embedLike.image.url);
      }
    }

    if (embedLike.thumbnailUrl) {
      embed.setThumbnail(embedLike.thumbnailUrl);
    }

    if (embedLike.timestamp) {
      embed.setTimestamp(embedLike.timestamp);
    }

    if (embedLike.title) {
      embed.setTitle(embedLike.title);
    }

    if (embedLike.url) {
      embed.setURL(embedLike.url);
    }

    return embed;
  }
}

exports.MessageExpectTest = MessageExpectTest;
